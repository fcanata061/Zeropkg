Olá ChatGPT,

Quero que você gere um gerenciador de pacotes source-based para Linux chamado `zeropkg`, escrito em Python 3, usando todos os detalhes do arquivo `zeropkg_full_manager.txt` que vou fornecer abaixo.

Regras importantes:

1. Código completo e funcional; não entregue esqueleto ou pseudocódigo.
2. Todos os módulos devem ser integrados: CLI, download, extração, patches, sandbox, build, instalação, logs coloridos, dependências, toolchains, auditoria, notificações.
3. CLI com abreviações, dry-run, --ask/-a, tail em tempo real, animado e colorido.
4. Uso de sandbox + fakeroot para instalação temporária antes de mover para /usr.
5. Todos os logs e registros de arquivos instalados devem ser salvos e acessíveis.
6. O arquivo de configuração externo /etc/zeropkg/config.yaml deve ser usado por todos os módulos.
7. Suporte a múltiplas linguagens (Autotools, Rust/Cargo, Python, Go, Java) e opção custom.
8. Resolução de dependências topológica, reversa e por camadas profundas, incluindo updates automáticos via HTTP/HTTPS/Git/Rsync/FTP.
9. Inclua exemplo de meta.yaml para testar build, instalação, remoção e update.
10. Múltiplos downloads e patches por camada devem ser suportados.
11. Logs coloridos, históricos, visualização em tempo real, e notificação via notify-send sobre updates.
12. Suporte a múltiplas versões coexistindo e gerenciamento completo de toolchains.
13. Limpeza completa de sandbox, build, logs e prefix disponível via comando clean.
14. Todo passo deve ser registrado, versionado e logado.
15. Se o código for muito grande, divida em módulos funcionais, mas forneça todos os módulos completos prontos para salvar e rodar.

Objetivo: Quero poder rodar o gerenciador completo só copiando os arquivos, configurando o YAML de exemplo e executando no Linux sem precisar de ajustes adicionais.

Arquivo de referência:

```
Zeropkg - Gerenciador de Pacotes Source-Based Linux em Python

Funcionalidades:

* Sandbox e PREFIX isolados
* Downloads HTTPS e Git
* Extração multi-formato
* Aplicação de múltiplos patches por camada
* Hooks pré/pós remove, compile, patch, install
* Criação da pasta build para fazer a construção
* Build para Autotools, Rust/Cargo, Python, Go, Java, e custom
* Dependências topológicas, reversas, camadas profundas
* Registro completo em logs coloridos
* CLI com abreviações, dry-run, ask/confirm
* Atualização automática de pacotes e notificações via notify-send
* Configuração externa em /etc/zeropkg/config.yaml
* Multi-versões coexistindo, toolchains, auditoria do sistema, python, bootstrap
  """

# Estrutura de pastas padrão (definida via /etc/zeropkg/config.yaml)

CONFIG_FILE = "/etc/zeropkg/config.yaml"
BUILD_DIR = None  # será lido do arquivo de config
SANDBOX_DIR = None
PREFIX = None
LOG_DIR = None
META_DIR = None
PATCH_DIR = None
TOOLCHAIN_DIR = None

# Configuração YAML de exemplo (/etc/zeropkg/config.yaml)

CONFIG_YAML = """
build_dir: /var/zeropkg/build
sandbox_dir: /var/zeropkg/sandbox
prefix: /var/zeropkg/prefix
log_dir: /var/zeropkg/logs
meta_dir: /usr/ports/zeropkg
patch_dir: /usr/ports/zeropkg/<diretorio>/<programa/patches # exemplo: /usr/ports/zeropkg/base/gcc/patches
toolchain_dir: /usr/local/toolchains
path:
python: /usr/bin/python3
rust: /usr/bin/rustc
go: /usr/bin/go
java: /usr/bin/java
$PATH:/usr/bin:/usr/sbin:/usr/lib:/usr:/bin:$PATH
"""

# Exemplo de meta.yaml (/usr/ports/zeropkg/base/binutils/binutils-pass1-2.41.meta)

META_YAML = """
package:
  name: binutils-pass1
  version: 2.41
  release: 1
  category: toolchain
  summary: "Binutils (passo 1) — conjunto de ferramentas para linking/assembly (bootstrap)"
  description: |
    Este é o primeiro estágio de compilação do GNU Binutils, usado no processo
    de construção de toolchain cross-compilation (LFS bootstrap). Ele instala
    apenas as ferramentas mínimas necessárias para compilar o GCC pass1.

upstream:
  url: https://ftp.gnu.org/gnu/binutils/binutils-2.41.tar.xz
  protocol: https
  checksum: "sha256:fc7b99ecbf5eebf2f61fae50a6f9712b3a793bcee664f645dd5bb7b2d8e9f822"

dependencies:
  build:
    - gcc
    - make
    - bash
    - coreutils
    - gawk
    - texinfo
  runtime: []

environment:
  variables:
    LFS: "/mnt/lfs"
    LFS_TGT: "x86_64-lfs-linux-gnu"
    PATH: "$LFS/tools/bin:/usr/bin:/bin"

prepare:
  steps:
    - "tar -xf binutils-2.41.tar.xz"
    - "cd binutils-2.41"
    - "mkdir -v build && cd build"

build:
  steps:
    - "../configure --prefix=$LFS/tools \
        --with-sysroot=$LFS \
        --target=$LFS_TGT \
        --disable-nls \
        --disable-werror"
    - "make -j$(nproc)"

install:
  steps:
    - "make install DESTDIR=$LFS"

hooks:
  pre-configure: [echo 'Preparando pra configurar']
  post-configure: []
  pre-build: []
  post-build: []
  pre-install: []
  post-install:
    - "echo 'Binutils pass1 instalado em $LFS/tools'"
  pre-remove: []
  pos-remove: []

    """

# Nota: O script completo zeropkg em Python deve conter módulos para:

# - leitura e parsing do config.yaml

# - download HTTPS e Git

# - extração multi-formato (tar, zip, tar.gz, tar.xz, tar.bz2)

# - aplicação de patches em camadas

# - sandbox + fakeroot para instalação temporária

# - build para múltiplas linguagens e custom scripts

# - registro de arquivos instalados e logs coloridos

# - CLI com abreviações, dry-run, --ask/-a, list, search, info, update, bootstrap, clean

# - resolução de dependências topológica e reversa profunda 

# - gerenciamento de toolchains, múltiplas versões coexistindo

# - auditoria do sistema e correção de vulnerabilidades

# - atualização automática de pacotes e notificação via notify-send

# Observação: este arquivo é um resumo e modelo de configuração e metadados,

# pronto para ser transformado em arquivo Python funcional zeropkg.py.

# Para uso real, cada seção deve ser implementada com funções e classes,

# importações, exceções, subprocess, threading (para logs em tempo real) e

# manipulação de diretórios sandbox, prefix, build e patches.

# Estrutura de execução típica:

# 1. ler config.yaml

# 2. ler meta.yaml do pacote desejado

# 3. resolver dependências topológicas/reversas/profunda/arvore

# 4. baixar fontes via HTTPS/Git

# 5. verificar checksum/sha256

# 6. descompactar arquivos para build_dir

# 7. aplicar patches por camada

# 8. executar hooks pré-patch, pós-patch, pré-build, build, pós-build, pré-install, pós-install

# 9. compilar com build tools correspondentes (autotools, cargo, go, python, java, custom)

# 10. instalar no sandbox usando fakeroot

# 11. registrar arquivos e logs

# 12. mover para PREFIX ou empacotar

# 13. executar hooks pré-instalação e pós-instalação

# 14. atualizar registros e enviar notificações se necessário

# CLI esperada: e adicionar combinações zeropkg -inv

# zeropkg <programa> --ask/-a # ask é usado pra parar a tela e perguntar se deseja proceguir,e faz todo o processo,empacota e instala em /usr

# zeropkg remove/-r <programa> --dry-run # para simular o que vai acontecer

# zeropkg update/-u <programa> --dry-run # para simular e ver o que acontece.

# zeropkg list

# zeropkg --sync # Sincroniza o repo git e baixa repo com atualizações.

# zeropkg revdep-rebuild   # reconstrói pacotes com libs quebradas.

# zeropkg revdep-rebuild --pretend  # simula o que vai acontecer.

# zeropkg revdep-rebuild --library libssl.so.1.1 # força rebuild de libs específicas

# zeropkg etc-update         # atualiza arquivos em /etc interativamente.

# zeropkg glsa-check -t all         # lista pacotes vulneráveis

# zeropkg glsa-check -f all         # corrige pacotes vulneráveis

# zeropkg glsa-check -p all         # simula correção

# zeropkg zerolop -l           # mostra pacotes instalados recentemente

# zeropkg zerolop -t <nome>             # mostra tempo de compilação do gcc

# zeropkg-rebuild --all --pretend    # estima tempo rebuild

# zeropkg --list <nome>        # mostra versões instaladas

# zeropkg --files <nome>         # lista arquivos do pacote

# zeropkg --belongs <caminho/programa>  # mostra pacote dono do arquivo

# zeropkg --quickpkg <nome>             # cria pacote binário do programa

# zeropkg --depends <nome>            # mostra dependências do programa

# zeropkg -k <nome>          # instala usando binário se existir no cache ou diretórios específico. 

# zeropkg-qlist -I               # lista todos pacotes instalados

# zeropkg-kernel --all             # compila kernel + initramfs automático

# zeropkg-kernel --set <versão do kernel>     # seta versao do kernel e cria o link para kernel no diretorio /usr/src

# zeropkg-kernel --list            # lista todas as versões do kernel instaladas.

# zeropkg --noreplace (-n)          # Não reinstala pacotes já presentes

# zeropkg-doctor          # varrer o sistema todo em busca de todo tipo de problemas,links,órfãos,libs,pacotes quebrados,problema pra compilar,versão de programa,falta de arquivo de configuração de algum programa,duplicidade de arquivo,remoção de versão antiga não usada,revdep e arrumar.

# zeropkg-doctor --dry-run      # apenas simula mostra o iria acontecer.

# zeropkg --jobs=N (-j)             # Número de jobs paralelos

# zeropkg --load-average=N (-l)     # Limite de carga média

# zeropkg --keep-going              # Continua mesmo após erros

# zeropkg --resume                  # Retoma última compilação interrompida

# zeropkg --nodeps                  # Ignora dependências

# zeropkg --quiet-build y/n         # Controla verbosidade de compilação

# zeropkg --fail-clean y/n          # Limpa diretórios temporários após falhas

# zeropkg --resume                  # Retoma merges interrompidos

# zeropkg --ignore-built-operator-deps   # Ignora algumas dependências específicas

# zeropkg --ask (-a)                # Pergunta antes de executar

# zeropkg --searchdesc (-S)         # Busca também em descrições

# zeropkg --verbose (-v)            # Saída detalhada

# zeropkg --tree                    # Exibe árvore de dependências

# zeropkg --columns                 # Saída em colunas

# zeropkg --quiet                   # Menos saída

# zeropkg -p, --pretend             # Simula ação (não executa)

# zeropkg -D, --deep                # Considera dependências profundas

# zeropkg search/-s <nome>

# zeropkg info/-i <nome>

# zeropkg-rebuild --all # para recompilar todo o sistema organizando dependências.

# zeropkg-bootstrap --set, --install, --remove, --list, --rebuild, --verifier

# zeropkg-python --set, --install, --remove, --list, --rebuild, --verifier

# zeropkg-toolchain --set, --install, --remove, --list, --rebuild, --verifier

# zeropkg-java --set, --install, --remove, --list, --rebuild, --verifier

# zeropkg-rust --set, --install, --remove, --list, --rebuild, --verifier

# zeropkg-clean # limpa todo o sistema tudo cache,logs,registro,diretórios de trabalho,diretórios do sandbox,arquivos perdidos,pastas,tudo sem utilidade.

# Opções: -a/--ask, --dry-run, colorido, animado, logs em tempo real

# Logs:

# Devem ser armazenados em $LOG_DIR, coloridos, separados por pacote, data e hora,

# permitindo visualização histórica ou em tempo real (tail -f).

# Dependências:

# Separar compile-time e run-time, com versionamento de pacotes e toolchains.

# Suporte a múltiplos downloads e múltiplos patches por pacote e camada.

# Notificação de updates:

# Arquivo de resumo com contagem de updates (críticos, urgentes, normais) para bar.

# Notificação via notify-send

```
Por favor, gere o código Python completo, incluindo todos os módulos, CLI, funções de build, sandbox, download, extração, patches, logs coloridos, hooks, resolução de dependências, atualização automática, notificação, dry-run, --ask/-a, limpeza e suporte a múltiplas linguagens e toolchains e bootstrap.
